/* General styling */
* {
    box-sizing: border-box;
  }
  
  body {
    font-family: Arial, Helvetica, sans-serif;
    background-color: lightgray;
  }
  
  .container {
    /* padding: 12px; */
    border: 2px dashed black;
  }
  
  .item {
    padding: 12px;
    font-size: 18px;
    text-transform: uppercase;
    border-radius: 6px;
  }
  
  .item:nth-child(1) {
    background-color: #845ec2;
  }
  .item:nth-child(2) {
    background-color: #0081cf;
  }
  .item:nth-child(3) {
    background-color: #d65db1;
  }
  .item:nth-child(4) {
    background-color: #ff9671;
  }
  .item:nth-child(5) {
    background-color: #00c9a7;
  }
  .item:nth-child(6) {
    background-color: #c34a36;
  }
  
  /* FLEXBOX - CHILDREN */
  
  .container {
    display: flex;
    /* flex-wrap: wrap; */
    /* flex-direction: column; */
    gap: 6px;
    /* align-items:center; */
  }

  /* ORDER */
  /* Първоначалната стойност е 0. Елементите се подреждат спрямо техния order във възходящ ред. 
      Аако елементите са с един и същи order, те ще се подредят според декларацията им в HTML файла.  
    */
  /* .item:nth-child(1) {
    order: 1; 
    
  } */

/* ----------- */

  /* FLEX-SHRINK */
  /* Първоначалната тойност е 1. При негативна стойност или 0 той се изключва. Свързан е с това каква да бъде
      стъпката с която елементите да намалят при липсата на разстояние. За да работи не трябва да е включен flex-wrap 
      на контейнера, който е flex. Когато стойността е една и съща за всички не елементи, не е видима функционалността. 
      За да стане видима е необходимо (при нужда) да зада дем по-голяма стойност на някой елемент и така той спрямо останалите елементи 
      ще намаля с по-голяма стъпка/скорост при липсата на разстояние.
  */
/* .item {
  flex-shrink: 1;
} */

/* ----------- */

/* GROW */
/* Първоначалната му стойност е 0, което означава че е изключена тази функционалност. Свързана е с това каква да бъде стъпката на
    нарастване на елементите и колко от празното пространство, на контейнера да се добави към тях при нарастване на големината на контейнера.
    При пълна разгърнатост на контейнера, елементите са толкова големи, че да бъдат от край до край (по дължина) на контейнера.
    Доста прилича на flex-shrink но работи на "обратния принцип. Отново flex-wrap трябва да бъде изключен."
*/
/* .item {
  flex-grow: 1;
} */

/* ----------- */

/* FLEX-BASIS */
/* с това пропърти се задава първоначалния размер (широчината) на нашия елемент.
    Това е напълно възможно да се постигне и с width. За разлика от width и height, който работят за всеки елемент, 
    flex-basis работи в контекста на flex - трябва елементите да са част от контейнер, чийто displey е flex. Имаме достъп и до 
    следното пропърти flex: 0 1 auto;. Това значи, че елемента има за grow 0, за shrink 1  и basis auto, което е еквивалент на width auto.
    Вместо да се изписват всичките пропърита, това може да бъде постигнато просто с flex: grow, shrink basis;.
    Интересно е неговото поведение в съчетаиние с flex-direction: column; на parent-а. При водител с flex-direction: column; и 
    и за дете с flex-basis (елемента ще е от край до край на самостоятелен ред и ще се въздейства върху височината.), резултата ще бъде различен,
    ако при същия родетел и детето е с width (елеемента остава със зададената широчина и височина спрямо съържанието.) вместо flex-basis. 

*/
/* .item:nth-child(3) {
  flex-basis: 100px;
} */

/* ----------- */

/* ALIGN-SELF */
/* С това пропърти на детето може да се контролира позицията на самото дете. */
/* .item:nth-child(4) {
  flex-basis: 200px;
}
.item:nth-child(5) {
  align-self:flex-start;
} */